\chapter{Standard Libraries}

The ACM ICPC, at the time of this writing, allows the use of the JDK 1.6 libraries as well
as the C++ STL.  Knowledge and mastery of the existing JDK classes is crucial for success.
This chapter reviews some of the more commonly used classes.

\section{Collection Classes}

\subsection{Object Equivalence}
\label{sec:objequivalence}

Java allows you to define and equivalence relationship between objects using the
\code{Object.equals} method, which is required for some problems.  If implemented,
a conforming \code{hashCode} method must be implemented as well.
Here are some hints.

\begin{itemize}
\sloppypar
\item \textbf{Avoid gratuitous implementations.}  In the vast majority of cases,
you will not need your own \code{equals/hashCode} function!  You only need equals/hashCode
if your object is used as a key (not value!) in a Map or Set, \textbf{and} if the
default implementation of equals (``two objects are equal if they are the same'') does
not suffice.   Simply needing to store objects in a set, or using them as a map key,
is not a justification for implementing equals().
An example of where equals is needed are search problems in a state space - you may 
create a state instance that is equal to an already explored state kept track of
in a 'visited' set or map.

\item \textbf{Implement equals() correctly}.
You need to compare all relevant fields to one another.
\begin{minted}[fontsize=\footnotesize]{java}
@Override
public boolean equals(Object _that) {
    State that = (State)_that;
    return this.field1 == that.field1 && ... && this.fieldn == that.fieldn;
}

// or, as appropriate
@Override
public boolean equals(Object _that) {
    State that = (State)_that;
    return this.field1.equals(that.field1) && ... && this.fieldn.equals(that.fieldn);
}
\end{minted}
For clarity, I recommend for \code{equals()} to always consider all fields, and 
to not include irrelevant fields in the object.  (That is also why I like separate
previous hop maps rather than previous hop fields, or distance fields in BFS implementations,
see Section~\ref{sec:bfs}.)  The problem with selectively including some fields
in the comparison, and not others, is that it opens the door to mistakes in which
you accidentally use information from the wrong object.

\item \textbf{Understand the equals/hashCode contract}.
The contract says two objects that are equal must have the same hashCode().
It does not require that if two objects have the same hashCode() they must
be equals().  

\item \textbf{Implement hashCode() efficiently.} 
Rely on built-in functions, such as Arrays.hashCode() for arrays, or the built-in
hashCode() functions for Strings and Lists, which are known to be good.

\item \textbf{Consider hashCode()'s distribution.} 
The contract would be met by a degenerate function that returns always zero, but this
would create terrible performance - in a hash map, all objects would be mapped
to the same slot, resulting in linear lookup performance.
The chosen hash function should provide a distribution of hash values
that is as uniformly random as possible. 
Remember that Integer.hashCode does not use a 
\href{http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function}{Fowler-Noll-Vo}
hash, but rather returns the integer itself; the resulting randomness will be
small, especially if the number of items added dwarfs the range in which that integer varies.

When combining the hashes of fields, prefer bitwise xor (\^) over addition
or multiplication.  As an aside, it is not necessary that the lower bits are uniformly distributed -
Java's HashMap implementation does not perform a simple modulo, but rather draws
from higher-order bits, too:

\inputjava{javautilHashMap}

In my 2011/H Solution~\ref{sec:2011-h-rally}, execution time reduced from 87 to 29 
seconds by changing the hash function to use xor of all three components instead 
of multiplication of two components.

\end{itemize}

\subsection{Comparators}
\label{sec:comparators}

The most common uses of comparators are for sorting (Arrays.sort, Collections.sort, Collections.max, etc.), 
binary trees (java.util.TreeMap), and sorted queues (java.util.PriorityQueue).
Each use entails pitfalls.

\begin{itemize}
\item \textbf{Don't confuse partial orders with equality.}
    The contract of
    \href{http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html#compareTo(T)}{compareTo}
    requires that the relationship be transitive across $<$, $>$, and $=$.  That implies, for instance, 
    that if $a > b \land b = c$ then $a > c$.
    When dealing with partial orders do not treat incomparable elements as equal.  Notably,
    in a partial order, it's well possible that $a < c$ if $a > b \land \lnot (b < c \lor b > c)$
    Instead, either complete the order or use topological sorting.

\item \textbf{Make the ordering consistent with equals.}
    A comparator should return 0 iff .equals() returns true.   This is required, in particular, when
    using TreeSets.  See \href{http://docs.oracle.com/javase/6/docs/api/java/lang/Comparable.html#compareTo(T)}{compareTo}.

\end{itemize}


\section{Arbitrary Precision Integers}

Java's \code{java.math.BigInteger} class provides support for arbitrary precision integer arithmetic.
(\href{http://docs.oracle.com/javase/6/docs/api/java/math/BigInteger.html}{JDK Doc}).
In addition to arbitrary precision integer arithmetic, this class provides

\begin{itemize}
    \item \textbf{Immutability.}  All operations return new BigIntegers.

    \item \textbf{Modular arithmetic.}  
        This includes computation of residues (\code{mod}), modular exponentiation (\code{modPow}),
        and even multiplicative inverse (\code{modInverse}).

    \item \textbf{Bit operations.}  BigInteger can be used as arbitrary-length bit vectors (and often make more sense
        than using java.util.BitSet, which is a mutable implementation!)
        Notable methods (in addition to \code{flipBit}, \code{clearBit}, \code{setBit}, \code{testBit}:
    \begin{itemize}
    \item \code{bitCount()} returns number of 1-bits for a positive number.
\begin{minted}[fontsize=\footnotesize]{java}
% System.out.println(BigInteger.valueOf(30).bitCount());
4
\end{minted}
    \item \code{bitLength()} returns position of highest set bit.
\begin{minted}[fontsize=\footnotesize]{java}
% System.out.println(BigInteger.valueOf(16).bitLength());
5
% System.out.println(BigInteger.valueOf(15).bitLength());
4
\end{minted}
    \item \code{getLowestSetBit()} returns position of lowest set bit.
\begin{minted}[fontsize=\footnotesize]{java}
% System.out.println(BigInteger.valueOf(30).getLowestSetBit());
1
% System.out.println(BigInteger.valueOf(31).getLowestSetBit());
0
\end{minted}
    \end{itemize}
        \item Support for \textbf{probabilistic primality testing}
            (using \href{http://en.wikipedia.org/wiki/Millerâ€“Rabin_primality_test}{Miller-Rabin})
        via \code{isProbablePrime}, \code{nextProbablePrime}; support for GCD (via \code{gcd}).
    \item Like all \code{java.lang.Integer} and \code{java.lang.Long} it provides support for
        \textbf{base conversion} from/to strings for radices from 2 to 36.
\end{itemize}

\section{Bit Manipulation}

\textbf{\code{java.util.BitSet}} provides support for \textbf{mutable bit vectors} of arbitrary size.
Includes support for efficient iteration over set bits (\code{nextSetBit}); ditto for clear bits.
\begin{minted}[fontsize=\footnotesize]{java}
for (int i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i+1)) {
    // operate on index i here
}
\end{minted}

\textbf{\code{java.lang.Long.}}
An often overlooked class is \code{java.lang.Long}, which also provides support for
bit-twiddling on 64-bit longs.  Notable methods include
\begin{itemize}
\item \code{bitCount()} counts number of 1 bits.
\item \code{highestOneBit()} returns a long with only the highest bit set. (Note: unlike \code{BigInteger.bitLength()},
    this one returns not the position, but a long in which all other bits are cleared).
\begin{minted}[fontsize=\footnotesize]{java}
% System.out.println(Long.highestOneBit(16));
16
% System.out.println(Long.highestOneBit(15));
8
\end{minted}

\item \code{lowestOneBit()} returns long with only the lowest bit set.
\item \code{numberOfLeadingZeros} and \code{numberOfTrailingZeros} based on two's complement binary representation.
\begin{minted}[fontsize=\footnotesize]{java}
% System.out.println(Long.numberOfLeadingZeros(1));
63
% System.out.println(Long.numberOfLeadingZeros(1<<63));
0
% System.out.println(Long.numberOfLeadingZeros(2));
62
% System.out.println(Long.numberOfTrailingZeros(2));
1
\end{minted}

\item \code{reverse} reverse bits.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\section{Input}

The work horse for practically all input in ICPC problems is \code{java.util.Scanner}.  
Some notes on its recommended use.

\begin{itemize}
\item The default delimiter is always almost sufficient.  However, it can be changed.
    For instance, 2007/B Mobile's~\ref{sec:2007-b-mobile} input is free-formed S-Expressions
    spanning multiple lines, which are parsed using a delimiter that includes whitespace and
    a zero-width lookaround splitter, see Section~\ref{sec:lookaroundsplitting}.

\item Scanner does not support peeking at the next token without consuming it.
    Fortunately, this also isn't necessary in the vast majority of ICPC problems.  
    Should it be necessary, use the Scanner to fill an ArrayDeque of input tokens which
    can be peeked at.

\item Line-oriented vs. not Line-oriented input.  Many ICPC problems, though not all, use
    line-oriented input in which different pieces of information appear on different lines.
    Beware when mixing \code{nextLine()} and the other \code{next()} methods, such as \code{nextInt()}.
    For instance, to read the 2-line input
    \begin{verbatim}
    6 4
    orange
    \end{verbatim}
    into 2 ints and 1 string, the following calls would be necessary:
\begin{minted}[fontsize=\footnotesize]{java}
    int a = s.nextInt();    // read 6
    int b = s.nextInt();    // read 4, cursor is still one line 1
    s.nextLine();           // skip remainder of line
    String c = s.next();    // read orange; cursor now still on line 2
\end{minted}
    A recommended trick here is to nest Scanners and use only line-oriented 
    input on the outer scanner, like so:
\begin{minted}[fontsize=\footnotesize]{java}
    Scanner is = new Scanner(s.nextLine()); // read line with "6 4" and move to next line
    int a = is.nextInt();    // read 6
    int b = is.nextInt();    // read 4
    String c = s.nextLine(); // read orange and move to next line
\end{minted}
    This is particularly useful if parts of a line are optional, or depend on starting keywords.

\end{itemize}
